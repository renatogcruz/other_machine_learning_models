stats::predict(arvore, treino)
############################################
# Avaliar a árvore na base de treino
p_treino = stats::predict(arvore, treino)
base::factor(ifelse(p_treino[,2]>.5, "Y", "N"))
c_treino = base::factor(ifelse(p_treino[,2]>.5, "Y", "N"))
p_teste = stats::predict(arvore, teste)
c_teste = base::factor(ifelse(p_teste[,2]>.5, "Y", "N"))
tab <- table(c_treino, treino$Survived)
tab
acc <- (tab[1,1]+tab[2,2])/nrow(treino)
acc
sprintf('Acurácia na base de treino: %s ', percent(acc))
tab <- table(c_teste, teste$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(teste)
sprintf('Acurácia na base de treino: %s ', percent(acc))
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_treino <- data.frame(obs=treino$Survived,
pred=c_treino,
Y = p_treino[,2],
N = 1-p_treino[,2]
)
caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs))
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
########################
# Instalação de pacotes
pacotes <- c('titanic',    # carrega a base original titanic_treino
'tidyverse',  # Pacote básico de datawrangling
'rpart',      # Biblioteca de árvores
'rpart.plot', # Conjunto com Rpart, plota a parvore
'gtools',     # funções auxiliares como quantcut,
'Rmisc',      # carrega a função sumarySE para a descritiva
'scales',     # importa paletas de cores
'caret',      # Funções úteis para machine learning
"readxl",    #
"writexl",
"plotROC"
)
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
CurvaROC
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot(aval_teste, aes(d = obs, m = Y, colour='a')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de teste")
CurvaROC
##########################
# pós-poda (Grid Search) #
##########################
tab_cp <- rpart::printcp(arvore)
tab_cp
plotcp(arvore)
############################################
# Avaliar a árvore na base de treino
p_treino = stats::predict(arvore, treino)
c_treino = base::factor(ifelse(p_treino[,2]>.5, "Y", "N"))
p_teste = stats::predict(arvore, teste)
c_teste = base::factor(ifelse(p_teste[,2]>.5, "Y", "N"))
tab <- table(c_treino, treino$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(treino)
sprintf('Acurácia na base de treino: %s ', percent(acc))
tab <- table(c_treino, treino$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(treino)
sprintf('Acurácia na base de treino: %s ', percent(acc))
sink(file = '_out/script_002/output/acc_treino.txt')
print(acc)
sink()
tab <- table(c_teste, teste$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(teste)
sprintf('Acurácia na base de teste: %s ', percent(acc))
sink(file = '_out/script_002/output/acc_teste.txt')
print(acc)
sink()
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_treino <- data.frame(obs=treino$Survived,
pred=c_treino,
Y = p_treino[,2],
N = 1-p_treino[,2]
)
caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs))
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
CurvaROC
# salvando em .png
dev.print(file = '_out/script_002/figures/roc_treino.png',
device = png, width = 1024, height = 768, res = 2*72)
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot(aval_teste, aes(d = obs, m = Y, colour='a')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de teste")
CurvaROC
# salvando em .png
dev.print(file = '_out/script_002/figures/roc_teste.png',
device = png, width = 1024, height = 768, res = 2*72)
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_treino <- data.frame(obs=treino$Survived,
pred=c_treino,
Y = p_treino[,2],
N = 1-p_treino[,2]
)
caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs))
sink(file = '_out/script_002/output/aval_treino.txt')
print(caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs)))
sink()
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
sink(file = '_out/script_002/output/aval_teste.txt')
print(twoClassSummary(aval_teste, lev=levels(aval_teste$obs)))
sink()
rpart::printcp(arvore)
##########################
# pós-poda (Grid Search) #
##########################
tab_cp <- rpart::printcp(arvore)
tab_cp
plotcp(arvore)
##########################
# pós-poda (Grid Search) #
##########################
tab_cp <- rpart::printcp(arvore)
tab_cp
sink(file = '_out/script_002/output/tab_cp_pos_poda.txt')
print(tab_cp)
sink()
sink(file = '_out/script_002/output/tab_cp_pos_poda.txt')
print(tab_cp)
sink()
plotcp(arvore)
# salvando em .png
dev.print(file = '_out/script_002/figures/arvore.png',
device = png, width = 1024, height = 768, res = 2*72)
tab_cp[which.min(tab_cp[,'xerror']),]
cp_min <- tab_cp[which.min(tab_cp[,'xerror']),'CP']
cp_min
set.seed(1)
arvore_poda <- rpart::rpart(Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,
data=treino,
method='class',
xval=0,
control = rpart.control(cp = cp_min,
minsplit = 1,
maxdepth = 30)
)
arvore_poda
p_treino = stats::predict(arvore_poda, treino)
c_treino = base::factor(ifelse(p_treino[,2]>.5, "Y", "N"))
p_teste = stats::predict(arvore_poda, teste)
c_teste = base::factor(ifelse(p_teste[,2]>.5, "Y", "N"))
#####
aval_treino <- data.frame(obs=treino$Survived,
pred=c_treino,
Y = p_treino[,2],
N = 1-p_treino[,2]
)
caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs))
sink(file = '_out/script_002/output/aval_treino_pos_poda.txt')
print(caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs)))
sink()
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
CurvaROC
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
CurvaROC
# salvando em .png
dev.print(file = '_out/script_002/figures/CurvaROC_pos_poda.png',
device = png, width = 1024, height = 768, res = 2*72)
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
CurvaROC
# salvando em .png
dev.print(file = '_out/script_002/figures/CurvaROC_pos_poda_treino.png',
device = png, width = 1024, height = 768, res = 2*72)
# salvando em .png
dev.print(file = '_out/script_002/figures/CurvaROC_pos_poda_treino.png',
device = png, width = 1024, height = 768, res = 2*72)
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot(aval_teste, aes(d = obs, m = Y, colour='a')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de teste")
CurvaROC
# salvando em .png
dev.print(file = '_out/script_002/figures/CurvaROC_pos_poda_teste.png',
device = png, width = 1024, height = 768, res = 2*72)
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot2::ggplot(aval_treino, aes(d = obs, m = Y, colour='1')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de treino")
CurvaROC
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
sink(file = '_out/script_002/output/aval_teste_pos_poda.txt')
print(twoClassSummary(aval_teste, lev=levels(aval_teste$obs)))
sink()
# Podemos usar o mesmo dataframe para fazer a curva ROC:
CurvaROC <- ggplot(aval_teste, aes(d = obs, m = Y, colour='a')) +
plotROC::geom_roc(n.cuts = 0) +
scale_color_viridis_d(direction = -1, begin=0, end=.25) +
theme(legend.position = "none") +
ggtitle("Curva ROC - base de teste")
CurvaROC
# salvando em .png
dev.print(file = '_out/script_002/figures/CurvaROC_pos_poda_teste.png',
device = png, width = 1024, height = 768, res = 2*72)
tab_cp
##########################
# pós-poda (Grid Search) #
##########################
tab_cp <- rpart::printcp(arvore)
sink(file = '_out/script_002/output/tab_cp_pos_poda_Grid_Search.txt')
print(tab_cp)
sink()
##########################
# pós-poda (Grid Search) #
##########################
tab_cp <- rpart::printcp(arvore)
plotcp(arvore)
########################
# Instalação de pacotes
pacotes <- c('titanic',    # carrega a base original titanic_treino
'tidyverse',  # Pacote básico de datawrangling
'rpart',      # Biblioteca de árvores
'rpart.plot', # Conjunto com Rpart, plota a parvore
'gtools',     # funções auxiliares como quantcut,
'Rmisc',      # carrega a função sumarySE para a descritiva
'scales',     # importa paletas de cores
'caret',      # Funções úteis para machine learning
"readxl",    #
"writexl",
"plotROC"
)
plotcp(arvore)
arvore
plotcp(arvore)
tab_cp[which.min(tab_cp[,'xerror']),]
sink(file = '_out/script_002/output/cp_min.txt')
print(cp_min)
sink()
tab_cp
set.seed(1)
arvore_poda <- rpart::rpart(Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,
data=treino,
method='class',
xval=0,
control = rpart.control(cp = cp_min,
minsplit = 1,
maxdepth = 30)
)
############################################
# Avaliar a árvore na base de treino
p_treino = stats::predict(arvore, treino)
c_treino = base::factor(ifelse(p_treino[,2]>.5, "Y", "N"))
p_teste = stats::predict(arvore, teste)
c_teste = base::factor(ifelse(p_teste[,2]>.5, "Y", "N"))
tab <- table(c_treino, treino$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(treino)
sprintf('Acurácia na base de treino: %s ', percent(acc))
###############################################
# Vamos separar a base em treinamento e teste #
set.seed(123)
bool_treino <- stats::runif(dim(titanic)[1])>.25
treino <- titanic[bool_treino,]
teste  <- titanic[!bool_treino,]
titanic %>% str
set.seed(123)
arvore <- rpart::rpart(Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,
data=treino,
method='class',
xval=5,
control = rpart.control(cp = 0,         # parametro de complexidade
minsplit = 1,   # minimo de obs por split
maxdepth = 30)  #
)
########################
# Instalação de pacotes
pacotes <- c('titanic',    # carrega a base original titanic_treino
'tidyverse',  # Pacote básico de datawrangling
'rpart',      # Biblioteca de árvores
'rpart.plot', # Conjunto com Rpart, plota a parvore
'gtools',     # funções auxiliares como quantcut,
'Rmisc',      # carrega a função sumarySE para a descritiva
'scales',     # importa paletas de cores
'caret',      # Funções úteis para machine learning
"readxl",    #
"writexl",
"plotROC"
)
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
######################################
# Vamos trabalhar com a base titanic #
# cuja fonte está na library(titanic)#
#data("Titanic")
#Titanic
setwd("C:\\Users\\Renato\\Dropbox\\pos_usp\\ML\\neural_network_algorithms\\aula_1")
titanic <- as.data.frame(read_excel("titanic.xlsx"))
###############################################
# Vamos separar a base em treinamento e teste #
set.seed(123)
bool_treino <- stats::runif(dim(titanic)[1])>.25
treino <- titanic[bool_treino,]
teste  <- titanic[!bool_treino,]
titanic %>% str
set.seed(123)
titanic$Embarked <- as.factor(titanic$Embarked)
titanic$Sex <- as.factor(titanic$Sex)
titanic$Survived <- as.factor(titanic$Survived)
###############################################
# Vamos separar a base em treinamento e teste #
set.seed(123)
bool_treino <- stats::runif(dim(titanic)[1])>.25
treino <- titanic[bool_treino,]
teste  <- titanic[!bool_treino,]
titanic %>% str
set.seed(123)
arvore <- rpart::rpart(Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked,
data=treino,
method='class',
xval=5,
control = rpart.control(cp = 0,         # parametro de complexidade
minsplit = 1,   # minimo de obs por split
maxdepth = 30)  #
)
# Verificando a complexidade da árvore
arvore$frame
############################################
# Avaliar a árvore na base de treino
p_treino = stats::predict(arvore, treino)
c_treino = base::factor(ifelse(p_treino[,2]>.5, "Y", "N"))
p_teste = stats::predict(arvore, teste)
c_teste = base::factor(ifelse(p_teste[,2]>.5, "Y", "N"))
tab <- table(c_treino, treino$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(treino)
sprintf('Acurácia na base de treino: %s ', percent(acc))
tab <- table(c_teste, teste$Survived)
acc <- (tab[1,1]+tab[2,2])/nrow(teste)
sprintf('Acurácia na base de teste: %s ', percent(acc))
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_treino <- data.frame(obs=treino$Survived,
pred=c_treino,
Y = p_treino[,2],
N = 1-p_treino[,2]
)
caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs))
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
##########################
# pós-poda (Grid Search) #
##########################
tab_cp <- rpart::printcp(arvore)
tab_cp
sink(file = '_out/script_002/output/tab_cp_pos_poda_Grid_Search.txt')
print(tab_cp)
sink()
plotcp(arvore)
tab_cp[which.min(tab_cp[,'xerror']),]
cp_min <- tab_cp[which.min(tab_cp[,'xerror']),'CP']
#####
aval_treino <- data.frame(obs=treino$Survived,
pred=c_treino,
Y = p_treino[,2],
N = 1-p_treino[,2]
)
caret::twoClassSummary(aval_treino, lev=levels(aval_treino$obs))
# Vamos calcular a área da curva ROC com uma função no Caret
# A função é o twoClassSummary, que espera como entrada um dataframe com esse layout:
# obs: uma coluna contendo um fator com as classes observadas
# pred: fator com as classes preditas
# <classe 1> (Y no caso): contém a probabilidade da classe 1
# <classe 2> (Y no caso): contém a probabilidade da classe 2
aval_teste <- data.frame(obs=teste$Survived,
pred=c_teste,
Y = p_teste[,2],
N = 1-p_teste[,2]
)
twoClassSummary(aval_teste, lev=levels(aval_teste$obs))
